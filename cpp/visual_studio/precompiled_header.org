

* precompiled header 预编译头文件

** 1、解决什么问题？
C++ 编译器是单独，分别编译的，每个cpp文件，进行预编译（也就是对#include，define 等进行文本替换），生成编译单元。编译单元是一个自包含文件，C++编译器对编译单元进行编译。考虑，头文件A.h被多个cpp文件（比如A1.cpp，A2.cpp）包含，每个cpp文件都要进行单独编译，其中的A.h部分就会被多次重复第编译，影响效率。

** 2、怎么解决？
把A.h以及类似A.h这样的头文件，包含到stdafx.h中（当然也可以是其他文件），在stdafx.cpp中包含stdafx.h，设置stdafx.cpp文件的属性，预编译头设置为 创建。对于原先包含A.h的cpp文件，删除#include "A.h"，改成包含stdafx.h，同时设置这些cpp文件（A1.cpp，A2.cpp）的属性，预编译头设置为 使用。这样的话，下次编译A1.cpp，A2.cpp的时候，对于A.h头文件中的那部分，就不需要编译了，节省时间。

** 3、预编译头文件原理
工程对预先编译的代码进行编译，会生成一个pch文件（precompiled header），包含了编译的结果。注意，可以对任何代码生成到pch中，但是生成pch是个很耗时的操作，因此，只对那些稳定的代码创建预编译头文件。

** 4、对于预编译头，分为：创建者，使用者，不使用者。
预编译头的创建者使用Yc选项
预编译头的使用者使用Yu选项
理论上一个工程推荐只有一个预编译头创建者


** 5、TimeStramp时间戳
- Time Stramp：时间戳是指文件属性里的创建，修改，访问的时间。每次，文件内容修改，时间戳都会更新为最新的时间，时间戳发生变化，说明文件被修改了。
- 注意：现在的编译器都有Time Stramp 功能，当编译整个工程的时候，只编译那些修改的cpp文件。但是，这并没有解决上面提到的问题。考虑A1.cpp经常修改，每次修改，都要对包含的A.h头文件部分，进行编译。
- Time Stramp解决的问题：对于没有修改过的cpp文件，不需要进行编译



